---
title: File-Based Routing
description: 'Your file structure defines your routes. No configuration required.'
---

Fuego uses a file-system based router inspired by Next.js App Router. Your file structure defines your routes.

## Basic Routing

Create `route.go` files to define API endpoints:

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <Folder name="users">
        <File name="route.go" />
      </Folder>
      <Folder name="posts">
        <File name="route.go" />
      </Folder>
    </Folder>
    <File name="route.go" />
  </Folder>
</FileTree>

This creates:
- `app/api/users/route.go` → `/api/users`
- `app/api/posts/route.go` → `/api/posts`
- `app/route.go` → `/`

## Handler Functions

Export functions named after HTTP methods:

```go
package users

import "github.com/abdul-hamid-achik/fuego/pkg/fuego"

// GET /api/users
func Get(c *fuego.Context) error {
    return c.JSON(200, []string{"alice", "bob"})
}

// POST /api/users
func Post(c *fuego.Context) error {
    return c.JSON(201, map[string]string{"status": "created"})
}

// PUT /api/users
func Put(c *fuego.Context) error {
    return c.JSON(200, map[string]string{"status": "updated"})
}

// PATCH /api/users
func Patch(c *fuego.Context) error {
    return c.JSON(200, map[string]string{"status": "patched"})
}

// DELETE /api/users
func Delete(c *fuego.Context) error {
    return c.NoContent()
}

// HEAD /api/users
func Head(c *fuego.Context) error {
    return c.NoContent()
}

// OPTIONS /api/users
func Options(c *fuego.Context) error {
    c.SetHeader("Allow", "GET, POST, PUT, PATCH, DELETE")
    return c.NoContent()
}
```

<Info>
All handlers must have the signature `func(c *fuego.Context) error`. Invalid signatures are skipped with a warning.
</Info>

## Dynamic Routes

Use `[param]` folders for dynamic segments:

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <Folder name="users">
        <File name="route.go" />
        <Folder name="[id]">
          <File name="route.go" />
        </Folder>
      </Folder>
    </Folder>
  </Folder>
</FileTree>

This creates:
- `/api/users` - static route
- `/api/users/:id` - dynamic route

```go
package users

import "github.com/abdul-hamid-achik/fuego/pkg/fuego"

// GET /api/users/:id
func Get(c *fuego.Context) error {
    id := c.Param("id")
    return c.JSON(200, map[string]string{"id": id})
}
```

### Multiple Parameters

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <Folder name="orgs">
        <Folder name="[orgId]">
          <Folder name="teams">
            <Folder name="[teamId]">
              <File name="route.go" />
            </Folder>
          </Folder>
        </Folder>
      </Folder>
    </Folder>
  </Folder>
</FileTree>

Maps to `/api/orgs/:orgId/teams/:teamId`

```go
func Get(c *fuego.Context) error {
    orgId := c.Param("orgId")
    teamId := c.Param("teamId")
    return c.JSON(200, map[string]string{
        "orgId":  orgId,
        "teamId": teamId,
    })
}
```

## Catch-All Routes

Use `[...param]` for catch-all routes:

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <Folder name="docs">
        <Folder name="[...slug]">
          <File name="route.go" />
        </Folder>
      </Folder>
    </Folder>
  </Folder>
</FileTree>

Maps to `/api/docs/*`

```go
func Get(c *fuego.Context) error {
    // /api/docs/api/users/create → slug = "api/users/create"
    slug := c.Param("slug")
    segments := strings.Split(slug, "/")
    return c.JSON(200, map[string]any{
        "slug":     slug,
        "segments": segments,
    })
}
```

**Examples:**
- `/api/docs/hello` → `slug = "hello"`
- `/api/docs/2024/01/my-post` → `slug = "2024/01/my-post"`

## Optional Catch-All

Use `[[...param]]` for optional catch-all (matches with or without segments):

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <Folder name="shop">
        <Folder name="[[...categories]]">
          <File name="route.go" />
        </Folder>
      </Folder>
    </Folder>
  </Folder>
</FileTree>

Matches:
- `/api/shop` → categories = `""`
- `/api/shop/electronics` → categories = `"electronics"`
- `/api/shop/electronics/phones` → categories = `"electronics/phones"`

## Route Groups

Use `(groupname)` folders to organize without affecting URLs:

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <Folder name="(marketing)">
        <Folder name="about">
          <File name="route.go" />
        </Folder>
        <Folder name="blog">
          <File name="route.go" />
        </Folder>
      </Folder>
      <Folder name="(shop)">
        <Folder name="products">
          <File name="route.go" />
        </Folder>
        <Folder name="cart">
          <File name="route.go" />
        </Folder>
      </Folder>
    </Folder>
  </Folder>
</FileTree>

Creates:
- `/api/about` (not `/api/marketing/about`)
- `/api/blog`
- `/api/products`
- `/api/cart`

<Tip>
Route groups are great for organizing code and applying shared middleware without affecting URLs.
</Tip>

## Private Folders

Following Next.js conventions, certain folders prefixed with `_` are private (not routable):

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <Folder name="users">
        <Folder name="[id]">
          <File name="route.go" />
        </Folder>
        <File name="route.go" />
      </Folder>
      <Folder name="_utils">
        <File name="auth.go" />
      </Folder>
    </Folder>
    <Folder name="dashboard">
      <Folder name="_components">
        <File name="Sidebar.templ" />
      </Folder>
      <File name="page.templ" />
    </Folder>
    <Folder name="_lib">
      <File name="database.go" />
    </Folder>
  </Folder>
</FileTree>

**Private folder prefixes:**
- `_components/` - UI components
- `_lib/` - Utility libraries
- `_utils/` - Helper functions
- `_helpers/` - Additional helpers
- `_private/` - Private implementation details
- `_shared/` - Shared code

<Tip>
For better organization, consider keeping private code outside the `app/` directory entirely, following Next.js best practices.
</Tip>

<Warning>
Fuego automatically creates symlinks in a `.fuego/imports/` directory for `[bracket]` directories and `(route groups)` to enable valid Go imports. These symlinks are managed automatically and the `.fuego/` directory should be added to `.gitignore`.
</Warning>

## Route Priority

Routes are matched in order of specificity:

1. **Static routes** (highest priority)
   - `/api/users/me` matches before `/api/users/:id`

2. **Dynamic routes**
   - `/api/users/:id` matches after static routes

3. **Catch-all routes** (lowest priority)
   - `/docs/*` matches last

**Example:**

```
GET /api/users/me   → matches /api/users/me (static)
GET /api/users/123  → matches /api/users/:id (dynamic)
GET /docs/anything  → matches /docs/* (catch-all)
```

## Viewing Routes

Use the CLI to list all routes:

```bash
fuego routes
```

Output:
```
  Fuego Routes

  GET     /                             app/route.go
  GET     /api/health                   app/api/health/route.go
  GET     /api/users                    app/api/users/route.go
  POST    /api/users                    app/api/users/route.go
  GET     /api/users/{id}               app/api/users/[id]/route.go

  Total: 5 routes
```

Add `--json` for machine-readable output:

```bash
fuego routes --json
```

## Handler Signature

All handlers must have this signature:

```go
func HandlerName(c *fuego.Context) error
```

<Warning>
Invalid signatures are skipped with a warning. Make sure your handlers match the expected signature.
</Warning>

## Complete Example

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="api" defaultOpen>
      <File name="middleware.go" />
      <Folder name="health">
        <File name="route.go" />
      </Folder>
      <Folder name="users">
        <File name="route.go" />
        <Folder name="[id]">
          <File name="route.go" />
        </Folder>
      </Folder>
      <Folder name="posts">
        <Folder name="[...slug]">
          <File name="route.go" />
        </Folder>
      </Folder>
      <Folder name="(admin)">
        <Folder name="settings">
          <File name="route.go" />
        </Folder>
      </Folder>
    </Folder>
    <File name="page.templ" />
    <File name="layout.templ" />
  </Folder>
</FileTree>

Routes created:
| Method | Route | File |
|--------|-------|------|
| GET | `/` | `app/page.templ` |
| GET | `/api/health` | `app/api/health/route.go` |
| GET,POST | `/api/users` | `app/api/users/route.go` |
| GET,PUT,DELETE | `/api/users/:id` | `app/api/users/[id]/route.go` |
| GET | `/api/posts/*` | `app/api/posts/[...slug]/route.go` |
| GET,PUT | `/api/settings` | `app/api/(admin)/settings/route.go` |

## File Precedence Rules

When multiple files exist in the same directory, Fuego follows these precedence rules:

### page.templ + route.go

If both `page.templ` and `route.go` exist in the same directory:

1. **If route.go has a `Get()` function**: `page.templ` takes precedence for GET requests. The `Get()` handler in route.go is ignored, and a warning is shown.
2. **If route.go has NO `Get()` function**: Both work together - `page.templ` handles GET, `route.go` handles POST, PUT, DELETE, etc.

<Warning>
When route.go's Get() handler conflicts with page.templ, a warning is shown during build/dev. The recommended patterns are:
- Move API logic to `app/api/` directory
- Use the data loader pattern (see below)
- Remove Get() from route.go if page.templ should handle GET
</Warning>

### Data Loaders

The cleanest pattern for pages that need server-side data is the **loader pattern**:

<FileTree>
  <Folder name="app" defaultOpen>
    <Folder name="dashboard" defaultOpen>
      <File name="loader.go" />
      <File name="page.templ" />
    </Folder>
  </Folder>
</FileTree>

**loader.go** - Loads data:
```go
package dashboard

import "github.com/abdul-hamid-achik/fuego/pkg/fuego"

type DashboardData struct {
    UserName string
    Stats    Stats
}

func Loader(c *fuego.Context) (DashboardData, error) {
    // Fetch from database, API, etc.
    return DashboardData{
        UserName: "Alice",
        Stats:    getStats(c),
    }, nil
}
```

**page.templ** - Renders UI:
```go
package dashboard

templ Page(data DashboardData) {
    <h1>Welcome, { data.UserName }</h1>
}
```

Fuego automatically wires them together:
```go
// Generated code:
app.Get("/dashboard", func(c *fuego.Context) error {
    data, err := dashboard.Loader(c)
    if err != nil {
        return err
    }
    return fuego.TemplComponent(c, 200, dashboard.Page(data))
})
```

Generate a loader with:
```bash
fuego generate loader dashboard
fuego generate loader users/_id --data-type UserDetailData
```

### Alternative: HTMX Pattern

For client-side data loading, use HTMX:

```go
// page.templ - no data parameter
templ Page() {
    <div hx-get="/api/dashboard" hx-trigger="load">
        Loading...
    </div>
}
```

See the [HTMX Integration](/docs/frontend/htmx) guide for more details.

## Next Steps

<CardGroup cols={2}>
  <Card title="Middleware" icon="layer-group" href="/docs/middleware/overview">
    Add cross-cutting concerns
  </Card>
  <Card title="Context API" icon="code" href="/docs/api/context">
    Request and response handling
  </Card>
  <Card title="Proxy" icon="shield" href="/docs/middleware/proxy">
    Request interception
  </Card>
  <Card title="Examples" icon="code" href="/docs/guides/examples">
    Working code samples
  </Card>
</CardGroup>
